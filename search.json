[
  {
    "objectID": "nostr_core.html",
    "href": "nostr_core.html",
    "title": "nostr_core",
    "section": "",
    "text": "This repository relies heavily on python-nostr for underlying functionality. This notebook will walk you through the key characteristics of the nostr protocol and also make some changes to the classes from python-nostr that will be used in the basic client implementation."
  },
  {
    "objectID": "nostr_core.html#what-is-nostr",
    "href": "nostr_core.html#what-is-nostr",
    "title": "nostr_core",
    "section": "What is nostr?",
    "text": "What is nostr?\nThis notebook will attempt to describe nostr via python code. There are many resources dedicated to describing nostr in words. See:\n\nthe readme on the nostr protocol github\nthe Nostr Improvement Proposal (NIPs) nostr protocol github has detailed descriptions of technical implementations and is very well-documented.\nusenostr.org for a basic and approachable description\nawesome-nostr for a complete list of tools and resources.\n\nIn short, nostr is a communication protocol that provides a relatively simple framework for events and metadata to be published to servers (relays) after being cryptographically signed using a private key. In orther words, the data published to the relays is visible by anyone, but provably created by the person who holds the private key associated with the event. A technical description of how the events are created can be found here and a current list of the different event types here.\nBecause of the simplicity and openness of the nostr protocol a long list of tools and clients with different purposes have already been built on the nostr protocol as can be seen on awesome-nostr. There will continue to be more as new people are exposed to the protocol and the accepted event types continue to expand.\nFundamentally, nostr relays and clients are built on a relatively simple set of tools - most of which can be described nicely by looking at the modules of python-nostr, which is what we’ll do here. Specifically, covered topics in this notebook can be accessed quickly via the sidebar and include:\n\nPrivateKey and PublicKey\nEvent\nRelay, RelayManager, and the MessagePool\nSubscription"
  },
  {
    "objectID": "nostr_core.html#private-and-public-keys",
    "href": "nostr_core.html#private-and-public-keys",
    "title": "nostr_core",
    "section": "Private and Public Keys",
    "text": "Private and Public Keys\nIn nostr, the private key is the root of “account” ownership. The public key is derived from a private key using the same eliptic curve cryptography that is used for bitcoint private and public key pairs. nostr events are then signed using Schnorr Signatures, which prove “ownership” of the event. We will cover events in more detail later.\nIn this documentation you will see two versions of the PublicKey and PrivateKey classes, one version loaded directly from the python-nostr.key module as key.Class and one with added hex and bech32 functionality as denoted without key. in front.\nFirst, let’s look at the PrivateKey classes\nBy default the class is instantiated with raw bytes as shown below\n\n\nPrivateKey\n\n PrivateKey (raw_secret:bytes=None)\n\nInitialize self. See help(type(self)) for accurate signature.\nInstantiation with no argument gives a new random private key\n\nprivate_key = PrivateKey()\nprint(private_key)\n\nPrivateKey(npub1j8l27...zthqnwmn00)\n\n\nmore commonly you will likely instantiate the private key from a hex string\n\nsource\n\n\nPrivateKey.from_hex\n\n PrivateKey.from_hex (hex:str)\n\n\nprivate_key_hex = private_key.hex()\nthe_same_private_key = PrivateKey.from_hex(private_key_hex)\nassert private_key.hex() == the_same_private_key.hex()\n\nor after the introduction of bech32 entities in NIP-19 (private keys denoted as nsec...) like so\n\n\n\nPrivateKey.from_nsec\n\n PrivateKey.from_nsec (nsec:str)\n\nLoad a PrivateKey from its bech32/nsec form\n\nprivate_key_bech32 = private_key.bech32()\nthe_same_private_key = PrivateKey.from_nsec(private_key_bech32)\nassert private_key.bech32() == the_same_private_key.bech32()\n\nThe PublicKey class from python-nostr has very similar characteristics to the private key class, but with the key difference that the public key can be generated from the private key and the reverse is not possible by design. Below are the docs for instantiating a PublicKey object in python-nostr\n\n\n\nPublicKey\n\n PublicKey (raw_bytes:bytes)\n\nInitialize self. See help(type(self)) for accurate signature.\nUnlike the PrivateKey class, the PublicKey class requires an input to be created. A random public key would mean that no one knows the associated private key and so that is not allowed. Instead, we will get our public key from the private key we already generated\n\npublic_key = private_key.public_key\nprint(public_key)\nassert isinstance(public_key, PublicKey)\n\nPublicKey(npub1j8l27...zthqnwmn00)\n\n\nThe public can can also be retrieved from a public hex\n\nsource\n\n\nPublicKey.from_hex\n\n PublicKey.from_hex (hex:str)\n\n\npublic_key_hex = public_key.hex()\nthe_same_public_key = PublicKey.from_hex(public_key_hex)\nassert public_key.hex() == the_same_public_key.hex()\n\nor an npub bech32 encoded public key\n\nsource\n\n\nPublicKey.from_npub\n\n PublicKey.from_npub (npub:str)\n\nLoad a PublicKey from its bech32/npub form\n\npublic_key_bech32 = public_key.bech32()\nthe_same_public_key = PublicKey.from_npub(public_key_bech32)\nassert public_key.bech32() == the_same_public_key.bech32()"
  },
  {
    "objectID": "nostr_core.html#nostr-events",
    "href": "nostr_core.html#nostr-events",
    "title": "nostr_core",
    "section": "Nostr Events",
    "text": "Nostr Events\nEvents are the key substance through which user communication happens over Nostr. Right now, the most common event type is a text_note, but there are many other event kinds that can be published to a nostr relay. Events are generally made up of the following:\n\nid - the hash of the event content - if the content of the a created event changes on a relay the old id would no longer match the hash of the content\npubkey - the public key of the author of the event\ncreated_at - a time stamp given to the event at time of creation\nkind - integer labeling the kind of event\ntags - a list of arrays with tags such as e for related events or p for related people (like mentions)\ncontent - the content of an event - the format of the content will vary depending on the kind of event. For a text_note (kind 1) this would be a string\nsignature - a signature generated from the private key associated with the public key and the event ID field - a valid signature ensures that anyone can check that a specific event was in fact signed by the private key of the author and that the content has not changed from the time the event was signed.\n\n\nNote: the above all applies specifically to event creation. An event can be republished across many relays by any party as long as the event data has not changed. Some relays have limits on the age of an event, but where the event lives and who put it there is completely irrelevant to the validity of an event. This has many interesting implications, some of which will be explored elsewhere in this module.\n\nIn python-nostr we create events like so:\n\nfrom nostr.event import Event, EventKind\nimport time\nimport pprint\nfrom fastcore.test import test_fail\n\n\n\nEvent\n\n Event (public_key:str, content:str, created_at:int=1674361640,\n        kind:int=<EventKind.TEXT_NOTE: 1>, tags:list[list[str]]=[],\n        id:str=None, signature:str=None)\n\nInitialize self. See help(type(self)) for accurate signature.\nAs example, we can create a new event\n\nevent = Event(\n    public_key=public_key.hex(),\n    content='this is a test',\n    kind=EventKind.TEXT_NOTE,\n    created_at=int(time.time(),)\n)\npprint.pprint(event.to_json_object())\n\n{'content': 'this is a test',\n 'created_at': 1674322515,\n 'id': '589ad714c2a36929abd4a817a2177c594d31e5c373948af9c22890f5590c17f6',\n 'kind': <EventKind.TEXT_NOTE: 1>,\n 'pubkey': '91feaf1b03c1dc0ed61163f77b4cf4d1821cce392983d4c68d82207a773f12ee',\n 'sig': None,\n 'tags': []}\n\n\nThe id hash is automatically generated from the event content, but the signature is blank because the event has not been signed with a private key. Below we can test signing an event with our real private key and also a random private key. We see that one event verifies that the public key, signature, and event id all match, while the event signed with the wrong private key does not verify.\n\nevent.sign(PrivateKey().hex())\nassert not event.verify()\nevent.sign(private_key.hex())\nassert event.verify()\npprint.pprint(event.to_json_object())\n\n{'content': 'this is a test',\n 'created_at': 1674322515,\n 'id': '589ad714c2a36929abd4a817a2177c594d31e5c373948af9c22890f5590c17f6',\n 'kind': <EventKind.TEXT_NOTE: 1>,\n 'pubkey': '91feaf1b03c1dc0ed61163f77b4cf4d1821cce392983d4c68d82207a773f12ee',\n 'sig': '23bfb21c8f9594ca068e52d7d752af05041fc710dcf3cf9c63064890c1687b8271cd0d36c874fed13dc5caa849b5cfae17c9969d182b0f36612f6585eb7e3ef3',\n 'tags': []}\n\n\nAdditionally, if we change the content and don’t recompute both the ID and the signature then the event will not verify.\n\nevent.created_at = time.time()\nevent.id = event.compute_id(public_key=event.public_key, created_at=event.created_at, kind=event.kind, tags=event.tags, content=event.content)\nassert not event.verify()\n\nevent.created_at = time.time()\nevent.sign(private_key.hex())\nassert not event.verify()\n\nAs long as we do both of these things the event verifies event with changed data.\n\nevent.created_at = time.time()\nevent.id = event.compute_id(public_key=event.public_key, created_at=event.created_at, kind=event.kind, tags=event.tags, content=event.content)\nevent.sign(private_key.hex())\nassert event.verify()\n\npython-nostr also supports other event types. The basic client module in this library can help build the content and tags of other event types in the correct format.\n\nfor kind in EventKind:\n    display(kind)\n\n<EventKind.SET_METADATA: 0>\n\n\n<EventKind.TEXT_NOTE: 1>\n\n\n<EventKind.RECOMMEND_RELAY: 2>\n\n\n<EventKind.CONTACTS: 3>\n\n\n<EventKind.ENCRYPTED_DIRECT_MESSAGE: 4>\n\n\n<EventKind.DELETE: 5>"
  },
  {
    "objectID": "nostr_core.html#relays-relay-management-and-the-message-pool",
    "href": "nostr_core.html#relays-relay-management-and-the-message-pool",
    "title": "nostr_core",
    "section": "Relays, Relay Management, and the Message Pool",
    "text": "Relays, Relay Management, and the Message Pool\nThough this package is primarily focused on the tools needed to run a nostr client - we will talk a bit about only enough to understand how they serve the client. More detailed information on relays can always be found in the NIPs section of the nostr github repository. For testing in this package we are going to use a python package called nostr-relay, which is installed alongside this package. It will run a local server that we can connect to instead of pinging public servers over and over with tests.\nRelays act as a simple data server for clients to interact with. Clients can publish events a relay and make requests (in the form of subscriptions) to get events back from a relay.\nConnections between clients and relays are made over a ‘websocket’ (typically handled by websockets in Python). A single websocket between a client and a relay can handle all data requests and typically should remain open as long as the client is live. Repeated connection and disconnections of websockets can put extra, unneeded strain on relays.\nThe message types that can be exchanged between a client and a relay are outlined here:\n\nclient to relay\n\nEVENT - A nostr event being published to a relay\nREQ - a client requesting a subscription to events from a relay\nCLOSE - a client closing a subscription\n\nrelay to client\n\nEVENT - an incoming event from a relay\nNOTICE - human-readable text with an explanation of any issues\nEOSE - a notice that all past stored messages have been transferred and that all future messages are newly published\nOK - a True/False response if an EVENT was published successfully\n\n\npython-nostr uses a MessagePool class to Queue the incoming stream of messages from the individial Relay websockets that are all running on different threads.\nThis package implements slightly modified versions of the Relay, RelayManager, and MessagePool classes found in python-nostr the basic usage is nearly identical, with a few added features that make building a the Client class easier. Added features that aren’t yet included in python-nostr:\n\na Connection context manager that is used to open connections on a Relay or RelayManager object using a with statement\nRelay\n\nan open_connections method on a single relay to mirror the thread-based connection opening used in the RelayManager class.\nan is_connected property to see if the websocket is open\n\nRelayManager\n\nadditional connection management methods to make relay manager more robust to inactive connections\nan __iter__ method that allows the client to access the Relay objects by iterating directly on the RelayManager object instead of RelayManager.relays.values()\n\n\n\nfrom nostr import relay, relay_manager\n\n\nRelay\nThe documentation below shows how a Relay is instantiated using python-nostr. The relay policy is defined by the RelayPolicy class\n\n\n\nRelay\n\n Relay (url:str, policy:nostr.relay.RelayPolicy,\n        message_pool:nostr.message_pool.MessagePool,\n        subscriptions:dict[str,nostr.subscription.Subscription]={})\n\nInitialize self. See help(type(self)) for accurate signature.\nRemember that in this package we will use a Relay class that inherits the python-nostr relay class. The same will go for the relay manager and the message pool.\n\nassert issubclass(Relay, relay.Relay) and \\\n       issubclass(RelayManager, relay_manager.RelayManager) and \\\n       issubclass(MessagePool, message_pool.MessagePool)\n\nBelow we test using the context manager from the Relay class in this package to connect and disconnect to a relay.\n\nimport ssl\n\n\nurl='ws://127.0.0.1:6969'\n\na_relay = Relay(\n    url=url,\n    policy=RelayPolicy(),\n    message_pool=MessagePool()\n    )\n\nassert not a_relay.is_connected\n\nwith a_relay.connection(ssl_options={'cert_reqs': ssl.CERT_NONE}):\n    time.sleep(.5)\n    print(f'Is the relay connected? {a_relay.is_connected}')\nassert not a_relay.is_connected\ntime.sleep(.5)\n\nINFO:     ('127.0.0.1', 51211) - \"WebSocket /\" [accepted]\n\n\n2023-01-21 09:35:27,716 - nostr_relay.web - INFO - Accepted 127.0.0.1-2a7e from Origin: http://127.0.0.1:6969\n\n\nINFO:     connection open\n\n\n2023-01-21 09:35:27,725 - websocket - WARNING - websocket connected\nIs the relay connected? True\n2023-01-21 09:35:28,212 - nostr_relay.web - INFO - Done 127.0.0.1-2a7e. sent: 0 bytes. duration: 0sec\n\n\nINFO:     connection closed\n\n\nand make sure that when it errors out it properly reports the error and proceeds to safely close the connection to the relay\n\nfrom fastcore.test import test_fail\n\n\ndef error_in_context():\n    with a_relay.connection(ssl_options={'cert_reqs': ssl.CERT_NONE}):\n        time.sleep(.5)\n        raise Exception()\ntest_fail(error_in_context)\nassert not a_relay.is_connected\n\nINFO:     ('127.0.0.1', 51216) - \"WebSocket /\" [accepted]\n\n\n2023-01-21 09:35:29,804 - nostr_relay.web - INFO - Accepted 127.0.0.1-b577 from Origin: http://127.0.0.1:6969\n\n\nINFO:     connection open\n\n\n2023-01-21 09:35:29,817 - websocket - WARNING - websocket connected\n2023-01-21 09:35:30,303 - nostr_relay.web - INFO - Done 127.0.0.1-b577. sent: 0 bytes. duration: 0sec\n\n\nINFO:     connection closed\n\n\nLet’s try to publish an event to a our local relay - typically you would do this through the relay manager as to publish content across multiple relays, but for testing purposes we will only use one.\n\n\n\nRelay.publish\n\n Relay.publish (message:str)\n\n\nfrom nostr import message_type\n\nWe need to get our message to the relay in the right format as specified by NIP-01\n\nmessage = [message_type.ClientMessageType.EVENT, event.to_json_object()]\nmessage = json.dumps(message)\nprint(message)\n\n[\"EVENT\", {\"id\": \"290b51301f55bf2ad51dba58e935cd6fbef8b9780c5e557a706c9403ae12b345\", \"pubkey\": \"91feaf1b03c1dc0ed61163f77b4cf4d1821cce392983d4c68d82207a773f12ee\", \"created_at\": 1674322516.899612, \"kind\": 1, \"tags\": [], \"content\": \"this is a test\", \"sig\": \"0c205776f1470aa1391d2556032b0a666fc9f88c5dfb1ddf968851a1186da8ea5ba3ca05c7202d68ee1b6b010323fd221220e13f16342cf319e7b347b12ed591\"}]\n\n\nAnd now we can publish it.\n\nwith a_relay.connection(ssl_options={'cert_reqs': ssl.CERT_NONE}):\n    time.sleep(.5)\n    a_relay.publish(message)\n\nINFO:     ('127.0.0.1', 51222) - \"WebSocket /\" [accepted]\n\n\n2023-01-21 09:35:35,170 - nostr_relay.web - INFO - Accepted 127.0.0.1-3be4 from Origin: http://127.0.0.1:6969\n\n\nINFO:     connection open\n\n\n2023-01-21 09:35:35,176 - websocket - WARNING - websocket connected\n\n\nINFO:     connection closed\n\n\n2023-01-21 09:35:35,679 - nostr_relay.web - INFO - 127.0.0.1-3be4 added 290b51301f55bf2ad51dba58e935cd6fbef8b9780c5e557a706c9403ae12b345 from 91feaf1b03c1dc0ed61163f77b4cf4d1821cce392983d4c68d82207a773f12ee\n2023-01-21 09:35:35,685 - nostr_relay.web - INFO - Done 127.0.0.1-3be4. sent: 0 bytes. duration: 1sec\n\n\nWe will try to read this later.\n\n\nRelay Manager\nGenerally, most interactions will happen through the RelayManager class. The relay manager allows easy interaction across multiple relays. Key methods are documented below\n\nsource\n\n\nRelayManager.add_relay\n\n RelayManager.add_relay (url:str, read:bool=True, write:bool=True,\n                         subscriptions=None)\n\n\nsource\n\n\nRelayManager.remove_relay\n\n RelayManager.remove_relay (url:str)\n\n\n\n\nRelayManager.publish_message\n\n RelayManager.publish_message (message:str)\n\nYou can also access connection statuses of the relays with RelayManager.connection_statuses. Below we use that property to check connections after making a RelayManager object, adding a Relay and connecting with the context manager.\n\nmanager = RelayManager()\nurls=[url]\nfor url in urls:\n    manager.add_relay(url=url)\n\nwith manager.connection():\n    print('opening')\n    print(manager.connection_statuses)\n    assert all(manager.connection_statuses.values())\n    print('closing')\nprint(manager.connection_statuses)\nassert not any(manager.connection_statuses.values())\n\nINFO:     ('127.0.0.1', 51225) - \"WebSocket /\" [accepted]\n\n\n2023-01-21 09:35:40,202 - nostr_relay.web - INFO - Accepted 127.0.0.1-ef13 from Origin: http://127.0.0.1:6969\n\n\nINFO:     connection open\n\n\n2023-01-21 09:35:40,211 - websocket - WARNING - websocket connected\nopening\n{'ws://127.0.0.1:6969': True}\nclosing\n{'ws://127.0.0.1:6969': False}\n2023-01-21 09:35:42,207 - nostr_relay.web - INFO - Done 127.0.0.1-ef13. sent: 0 bytes. duration: 2sec\n\n\nRelay objects that don’t connect will be remove automatically and throw a warning.\n\nmanager = RelayManager()\nurls=['ws://this-relay-doesnt-exist.com']\nfor u in urls:\n    manager.add_relay(url=u)\n\nwith manager.connection():\n    pass\n    assert len(manager.relays) == 0\n\nINFO:     connection closed\n\n\n2023-01-21 09:35:42,308 - websocket - ERROR - [Errno 8] nodename nor servname provided, or not known - goodbye\n\n\n/var/folders/3x/w083pw853418fqm2blj59w480000gn/T/ipykernel_10817/1720938854.py:40: UserWarning: ws://this-relay-doesnt-exist.com is not connected... removing relay.\n  warnings.warn(\n\n\n\n\nMessage Pool\nBecause we have multiple open websockets, the connections are threaded in Python. The MessagePool class acts as a shared Queue where different types of messages from the relay can all be accessed. The only significant change from the python-nostr MessagePool to this package is allowing the client to chose whether it should only keep the first event or whether it should keep multiples of event messages across all relays. Keeping all responses from all relays will allow the client to check how well distributed the user content is across the relays.\n\nsource\n\n\nMessagePool\n\n MessagePool (first_response_only:bool=True)\n\nInitialize self. See help(type(self)) for accurate signature.\nThe key events to access the MessagePool in python-nostr are listed below. We will add more functionality at the client level to modify how these events are handled upon receipt.\n\n\n\nMessagePool.get_event\n\n MessagePool.get_event ()\n\n\n\n\nMessagePool.get_notice\n\n MessagePool.get_notice ()\n\n\n\n\nMessagePool.get_eose_notice\n\n MessagePool.get_eose_notice ()\n\nIn order to populate the message pool we need subscriptions."
  },
  {
    "objectID": "nostr_core.html#subscriptions",
    "href": "nostr_core.html#subscriptions",
    "title": "nostr_core",
    "section": "Subscriptions",
    "text": "Subscriptions\nThe nostr protocol requires clients to make requests (as subscriptions) to the relays in order to get events sent back (in our case, into the MessagePool). The REQ (request or subscription) query is also clearly outlined in NIP-01. A request must be labeled with a subscription_id and a series of filters that the relay will use to determine which events it should return. Current options for a single filter are as follow:\n\nids - a list of event IDs\nauthors - a list of authors (pubkeys), which could be something like a contact list\nkinds - a list of kinds, such as text_notes (1) or set_metadata (0)\ntags - a list of tags, like e event or p people tags\nsince - a time stamp that defines the earliest created_at that should be sent\nuntil - a time stamp that defines the latest created_at that should be sent\nlimit - a limit of events to return upon initial request to keep the client from being overwhelmed if the query is wide\n\nA list of filters is provided in a REQ message and the following happens:\n\nthe relay returns all events in past storage that meet the union of all the filter specifications (i.e. each filter is handled separately)\nthe relay would then send an End Of Stored Events notice with the subscription_id\nthe relay will continue to send newly published events that meet the criteria until 1 of the following occurs:\n\nthe websocket is closed (by any measure - intentional closure or client crash)\nno more events are being published because the until clause of a subscription is met\nthe client sends a request with the same subscription_id and it overwrites the initial behavior\nthe client sends a CLOSE message to close the subscription_id\n\n\n\nfrom nostr import filter\nfrom nostr import subscription\nimport uuid\n\n\n\nFilter\n\n Filter (ids:list[str]=None, kinds:list[int]=None, authors:list[str]=None,\n         since:int=None, until:int=None, tags:dict[str,list[str]]=None,\n         limit:int=None)\n\nInitialize self. See help(type(self)) for accurate signature.\n\n\n\nSubscription\n\n Subscription (id:str, filters:nostr.filter.Filters=None)\n\nInitialize self. See help(type(self)) for accurate signature.\nWe can create a subscription to request the event we created earlier\n\nfilters = filter.Filters([filter.Filter(ids=[event.id])])\nsubscription_id = str(uuid.uuid4())\nrequest = [message_type.ClientMessageType.REQUEST, subscription_id]\nrequest.extend(filters.to_json_array())\nmessage = json.dumps(request)\nprint(message)\n\n[\"REQ\", \"10000\", {\"ids\": [\"290b51301f55bf2ad51dba58e935cd6fbef8b9780c5e557a706c9403ae12b345\"]}]\n\n\nNow we can get that from the relay we published it to\n\nmanager = RelayManager()\nmanager.add_relay(url)\n\nwith manager.connection(ssl_options={'cert_reqs': ssl.CERT_NONE}):\n    time.sleep(.5)\n    manager.add_subscription(subscription_id, filters)\n    manager.publish_message(message)\n    time.sleep(.5)\n    while manager.message_pool.has_events():\n        event_msg = manager.message_pool.get_event()\n        print(f'event received from {event_msg.url} '\n                f'with subscription id {event_msg.url}\\n\\t'\n                f'{event_msg.event.content}')\n\nINFO:     ('127.0.0.1', 51244) - \"WebSocket /\" [accepted]\n\n\n2023-01-21 09:36:08,568 - nostr_relay.web - INFO - Accepted 127.0.0.1-eb74 from Origin: http://127.0.0.1:6969\n\n\nINFO:     connection open\n\n\n2023-01-21 09:36:08,577 - websocket - WARNING - websocket connected\n2023-01-21 09:36:11,075 - nostr_relay.db - INFO - 127.0.0.1-eb74/10000 query – events:1 duration:1ms\nevent received from ws://127.0.0.1:6969 with subscription id ws://127.0.0.1:6969\n    this is a test\n2023-01-21 09:36:11,577 - nostr_relay.web - INFO - Done 127.0.0.1-eb74. sent: 400 bytes. duration: 3sec\n\n\nINFO:     connection closed\n\n\nWe will use the Client class in this package to make subscriptions and publishing events even easier."
  },
  {
    "objectID": "vanity.html",
    "href": "vanity.html",
    "title": "vanity",
    "section": "",
    "text": "Here is an interesting article by Kris Constable about vanity addresses. This is a great usecase for our notifyr decorator because calculating vanity addresses can be quite slow if we are looking for long words.\nThis module will let you look for an npub or a hex vanity address that starts with a particular pattern."
  },
  {
    "objectID": "vanity.html#making-guesses",
    "href": "vanity.html#making-guesses",
    "title": "vanity",
    "section": "making guesses",
    "text": "making guesses\nIn this module you will find a guess_npub and guess_hex methods that are created from _guess_vanity. We are going directly back to the bits to get the best perfomance possible - this code is very similar to the code used to generate private keys in the nostr.PrivateKey class from python-nostr\n\nprivkey_hex, npub = guess_bech32()\nassert PrivateKey.from_hex(privkey_hex).public_key.bech32() == npub\n\n\nprivkey_hex, pubkey_hex = guess_hex()\nassert PrivateKey.from_hex(privkey_hex).public_key.hex() == pubkey_hex"
  },
  {
    "objectID": "vanity.html#checking-computer-hashrate",
    "href": "vanity.html#checking-computer-hashrate",
    "title": "vanity",
    "section": "checking computer hashrate",
    "text": "checking computer hashrate\nWe can make some functions to check the guess rate (hashrate)\n\nf'We estimate a hash rate of {1/_get_guess_time(guess_hex)} guesses per second'\n\n'We estimate a hash rate of 12579.831850745017 guesses per second'\n\n\n\nf'We estimate a hash rate of {1/_get_guess_time(_guess_vanity_slow)} guesses per second'\n\n'We estimate a hash rate of 6391.511961143656 guesses per second'\n\n\n\nf'We estimate a hash rate of {1/_get_guess_time(guess_bech32)} guesses per second'\n\n'We estimate a hash rate of 4996.315606723534 guesses per second'\n\n\nAnd use our hashrate to make some estimates of how quickly we can find certain vanity addresses\n\nsource\n\nexpected_performance\n\n expected_performance ()\n\n\nexpected_performance()\n\nThis is a random guessing process - estimations are an average, but the actual\n        time it takes to find a key could be significantly more or less than the estimate!\n        Please keep that in mind when choosing an option.\n        \nhex:\nIn one second you can expect to get 3.325667183387504 characters on average\nIn one minute you can expect to get 4.8023898322896335 characters on average\nIn one hour you can expect to get 6.2791124811917625 characters on average\nIn one day you can expect to get 7.425353106372053 characters on average\nIn one month you can expect to get 8.658037440762774 characters on average\n\n\n1 characters: it might take 0.0015834985552821308 seconds\n2 characters: it might take 0.025335976884514094 seconds\n3 characters: it might take 0.4053756301522255 seconds\n4 characters: it might take 6.486010082435608 seconds\n5 characters: it might take 103.77616131896973 seconds\n6 characters: it might take 1660.4185811035156 seconds\n7 characters: it might take 26566.69729765625 seconds\n8 characters: it might take 425067.1567625 seconds\n9 characters: it might take 6801074.5082 seconds\n10 characters: it might take 108817192.1312 seconds\n11 characters: it might take 1741075074.0992 seconds\n12 characters: it might take 27857201185.5872 seconds\n13 characters: it might take 445715218969.3952 seconds\n14 characters: it might take 7131443503510.323 seconds\n15 characters: it might take 114103096056165.17 seconds\n16 characters: it might take 1825649536898642.8 seconds\n17 characters: it might take 2.9210392590378284e+16 seconds\n18 characters: it might take 4.6736628144605254e+17 seconds\n19 characters: it might take 7.477860503136841e+18 seconds\n20 characters: it might take 1.1964576805018945e+20 seconds\n\n\nnpub:\nIn one second you can expect to get 2.383159533953474 characters on average\nIn one minute you can expect to get 3.564537653075178 characters on average\nIn one hour you can expect to get 4.745915772196882 characters on average\nIn one day you can expect to get 5.662908272341113 characters on average\nIn one month you can expect to get 6.64905573985369 characters on average\n\n\n1 characters: it might take 0.008282042550842743 seconds\n2 characters: it might take 0.26502536162696777 seconds\n3 characters: it might take 8.480811572062969 seconds\n4 characters: it might take 271.385970306015 seconds\n5 characters: it might take 8684.35104979248 seconds\n6 characters: it might take 277899.23359335936 seconds\n7 characters: it might take 8892775.4749875 seconds\n8 characters: it might take 284568815.1996 seconds\n9 characters: it might take 9106202086.3872 seconds\n10 characters: it might take 291398466764.3904 seconds\n11 characters: it might take 9324750936460.492 seconds\n12 characters: it might take 298392029966735.75 seconds\n13 characters: it might take 9548544958935544.0 seconds\n14 characters: it might take 3.055534386859374e+17 seconds\n15 characters: it might take 9.777710037949997e+18 seconds\n16 characters: it might take 3.128867212143999e+20 seconds\n17 characters: it might take 1.0012375078860797e+22 seconds\n18 characters: it might take 3.203960025235455e+23 seconds\n19 characters: it might take 1.0252672080753456e+25 seconds\n20 characters: it might take 3.280855065841106e+26 seconds\n\n\n\n\nLets make the function…\n\nsource\n\n\ngen_vanity_pubkey\n\n gen_vanity_pubkey (startswith:str, style='hex')\n\nrandomly generate private keys until one matches the desire startswith for an npub or hex\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nstartswith\nstr\n\ncharacters that the public key should start with. More charsmeans longer run time\n\n\nstyle\nstr\nhex\n‘npub’ or ‘hex’ - npub is more commonly displayed on appswhile hex is the true base private key with no encoding,by default ‘hex’\n\n\nReturns\nPrivateKey\n\nreturns a private key object\n\n\n\n\nfrom fastcore.test import test_fail\n\nMake sure we don’t allow characters that will never happen - test that these cases fail\n\nfail = lambda _: gen_vanity_pubkey(startswith='b', style='npub')\ntest_fail(fail)\nfail = lambda _: gen_vanity_pubkey(startswith='g', style='hex')\ntest_fail(fail)\n\nGenerate a couple npubs!\n\nvanity_private_key_npub = gen_vanity_pubkey(startswith='23', style='npub')\nvanity_private_key_hex = gen_vanity_pubkey(startswith='23', style='hex')\n\nIt might take 0 seconds to find a npub pubkey that starts with npub123. Note that this is a very rough estimate and due to the random nature of finding vanity keys it could take MUCH longer.\nIt might take 0 seconds to find a hex pubkey that starts with 23. Note that this is a very rough estimate and due to the random nature of finding vanity keys it could take MUCH longer.\n\n\nAnd make sure it worked…\n\nassert vanity_private_key_npub.public_key.bech32().startswith('npub123')\nassert vanity_private_key_hex.public_key.hex().startswith('23')\n\nNow we can also make a version of this that notifies you.\nRemember that if you want a vanity notifyr that will go to a different address than the one you find in vanity_notifyr.notifyr_privkey_hex you can create your own notifyr like so:\nnew_vanity_notifyr = notifyr(gen_vanity_pubkey, recipient_address=your_address)"
  },
  {
    "objectID": "notifyr.html",
    "href": "notifyr.html",
    "title": "notifyr",
    "section": "",
    "text": "from nbdev.showdoc import *"
  },
  {
    "objectID": "notifyr.html#making-a-decorator-that-can-send-messages",
    "href": "notifyr.html#making-a-decorator-that-can-send-messages",
    "title": "notifyr",
    "section": "Making a decorator that can send messages",
    "text": "Making a decorator that can send messages\nWe are going to make a decorator that will store a private key in the keychain and send an encrypted message to itself. The private key will also be assigned to the decorated function as an attribute. The user can then log into any type of nostr client that can receive encrypted DMs to get notifications about python processing results or if the function errors out. Other projects like knockknock offer this sort of service, but take more leg work to get an account set up. Being able to randomly generate a Nostr private key makes this quick and painless.\n\nNote: There is some concern about the safety of the current encrypted message implementation. Please do not use this module for any sort of secure communication. You can see a Github issue on the topic here\n\n\nAnother note about keyring: This project is tested and runs on MacOS - the majority of it seems to build on linux, but seems to have some issues running on Linux due to keyring dependencies. The keyring documenation may help if you attempt to debug. I believe installing kwallet might be the eventual solution.\n\nFirst let’s make a helper function that will send the message\n\nsource\n\nsend_nostr_message\n\n send_nostr_message (notifyr_client:nostrfastr.client.Client, message:str,\n                     recipient_pubkey_hex:str)\n\na simple function that takes a client and a message and sends the message to the client pubkey from the client pubkey\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nnotifyr_client\nClient\nA client class that will send an encrypted message for us\n\n\nmessage\nstr\nA message that will be encrypted and sent\n\n\nrecipient_pubkey_hex\nstr\n\n\n\nReturns\nNone\n\n\n\n\nNext we are going to make helper functions to get and set credentials from keyring\n\n\n\nset_password\n\n set_password (service_name:str, username:str, password:str)\n\nSet password for the user in the specified service.\n\nsource\n\n\ndelete_private_key\n\n delete_private_key ()\n\ndelete the nostr hex private key from the computer key ring. This is not used in the decorator function, but may be used if need for testing\n\nsource\n\n\nget_private_key\n\n get_private_key ()\n\nget the nostr hex private key from the computer key ring\n\nsource\n\n\nset_private_key\n\n set_private_key (notifyr_privkey_hex:str)\n\nSet the private key in the computer keyring\n\n\n\n\nType\nDetails\n\n\n\n\nnotifyr_privkey_hex\nstr\nnostr hex private key\n\n\nReturns\nNone\n\n\n\n\nLet’s test setting and restoring the private key\nClear the private key from keychain\n\npriv_key_hex = get_private_key()\nif priv_key_hex is not None:\n    delete_private_key()\nassert get_private_key() is None\n\nTry setting a new one\n\npriv_key_hex = PrivateKey().hex()\nset_private_key(notifyr_privkey_hex = priv_key_hex)\nassert get_private_key() == priv_key_hex\n\nFinally we write the decorator function complete with - nostr client handling - start message, success message, error message handling - and setting the private key to the decorator function for easy user access\n\nsource\n\n\nconvert_to_hex\n\n convert_to_hex (pubkey:str)\n\nmake sure the pubkey is hex\n\n\n\n\nType\nDetails\n\n\n\n\npubkey\nstr\nhex or npub (bech32) pubkey\n\n\nReturns\nstr\nhex pubkey\n\n\n\n\nsource\n\n\nget_notifyr_privkey\n\n get_notifyr_privkey ()\n\nreturns a private key from keychain and sets a new one if one doesn’t exist\n/Users/runner/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/fastcore/docscrape.py:225: UserWarning: Unknown section Raises\n  else: warn(msg)\n\nsource\n\n\nnotifyr\n\n notifyr (func=None, recipient_pubkey:str=None, relay_urls:list[str]=None)\n\nA decorator that will set a nostr private key to `func.notifyr_privkey_hex and use that key to send an encrypted message to it’s own public key on the start and termination of the decorated function. The output will send whether the function runs completely or ends in an error with an informative message.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nfunc\nNoneType\nNone\nthe function to be decorated\n\n\nrecipient_pubkey\nstr\nNone\n\n\n\nrelay_urls\nlist\nNone\n\n\n\nReturns\nfunction\n\nthe decorated function\n\n\n\n\nsource\n\n\nnotifyr\n\n notifyr (func=None, recipient_pubkey:str=None, relay_urls:list[str]=None)\n\nA decorator that will set a nostr private key to `func.notifyr_privkey_hex and use that key to send an encrypted message to it’s own public key on the start and termination of the decorated function. The output will send whether the function runs completely or ends in an error with an informative message.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nfunc\nNoneType\nNone\nthe function to be decorated\n\n\nrecipient_pubkey\nstr\nNone\n\n\n\nrelay_urls\nlist\nNone\n\n\n\nReturns\nfunction\n\nthe decorated function\n\n\n\nNow we can decorate a couple functions!\n\npubkey = PrivateKey.from_hex(get_private_key()).public_key.bech32()\n@notifyr(recipient_pubkey=pubkey, relay_urls=['ws://127.0.0.1:6969'])\ndef success():\n    return True\n\n@notifyr\ndef another_success():\n    return True\n\n@notifyr\ndef raise_error():\n    raise Exception('Oh no! Process failed!')\n\nAnd test a successful function\n\nsuccess()\n\n2023-01-08 13:43:02,123 - websocket - WARNING - websocket connected\n\n\n/Users/ryanarmstrong/python/nostrfastr/nostrfastr/client.py:479: UserWarning: the current implementation of messages should be used with caution\n                    see https://github.com/nostr-protocol/nips/issues/107\n  warnings.warn('''the current implementation of messages should be used with caution\n\n\n2023-01-08 13:43:05,131 - websocket - WARNING - websocket connected\n\n\nTrue\n\n\n\nanother_success()\n\n2023-01-08 13:43:08,760 - websocket - WARNING - websocket connected\n2023-01-08 13:43:09,101 - websocket - WARNING - websocket connected\n2023-01-08 13:43:11,998 - websocket - WARNING - websocket connected\n2023-01-08 13:43:12,181 - websocket - WARNING - websocket connected\n\n\nTrue\n\n\n\nanother_success()\n\n2023-01-08 13:43:15,242 - websocket - WARNING - websocket connected\n2023-01-08 13:43:15,555 - websocket - WARNING - websocket connected\n2023-01-08 13:43:18,802 - websocket - WARNING - websocket connected\n2023-01-08 13:43:19,137 - websocket - WARNING - websocket connected\n\n\nTrue\n\n\nAnd test a failing function\n\nfrom fastcore.test import test_fail\n\n\ntest_fail(raise_error)\n\n2023-01-08 13:43:24,833 - websocket - WARNING - websocket connected\n2023-01-08 13:43:25,179 - websocket - WARNING - websocket connected\n2023-01-08 13:43:28,056 - websocket - WARNING - websocket connected\n2023-01-08 13:43:28,361 - websocket - WARNING - websocket connected\n\n\nRemember we can retrieve the private key to log into our messages from the keychain or from success.notifyr_privkey_hex or raise_error.notifyr_privkey_hex.\nIn this case you will either have to trust me that it works… or verify for yourself!"
  },
  {
    "objectID": "sentinel_client.html",
    "href": "sentinel_client.html",
    "title": "sentinel (in progress)",
    "section": "",
    "text": "As specified by NIP-01 a nostr event sent to a relay consists of a message in the format [\"EVENT\", <event JSON>] where the event JSON is a nostr event with a valid signature based upon the event content (public key, time stamp, content, tags, etc). The message sent to the relay doesn’t make any requirement about who sends a message or when (though some relays do not except events older than a certain threshold). This means that anyone can set up a client that reads events from one relay and publishes those events back to another relay - I will refer to this as rebroadcasting."
  },
  {
    "objectID": "sentinel_client.html#todo",
    "href": "sentinel_client.html#todo",
    "title": "sentinel (in progress)",
    "section": "TODO",
    "text": "TODO\nImplement a simple client class for rebroadcasting data called Sentinel\n\nfrom nbdev.showdoc import *\n\n\nfrom nostrfastr import client\n\n\nclass Sentinel(client.Client):\n    pass"
  },
  {
    "objectID": "client.html",
    "href": "client.html",
    "title": "client",
    "section": "",
    "text": "This notebook will implement and test a barebones client that can easily do the following - manage connections - manage private keys - publish event subscriptions (requests) - retrieve events and save to db - publish events"
  },
  {
    "objectID": "client.html#client-initialization",
    "href": "client.html#client-initialization",
    "title": "client",
    "section": "Client Initialization",
    "text": "Client Initialization\nthe basic client initializes with the following - a relay manager from python-nostr - set of relays that will be used for reading and writing (as of now all relays are used for both by default) - a message pool that acts as an incoming queue for messages from the relays - a user account - provided with a private key - able to publish new events - or with only a public key - only able to read and republish existing events - a sqlite database named by the publickey and located on the system user data directory by default - by default events are saved into the database as they are read out of the message queue from the message pool\n\nsource\n\nClient\n\n Client (public_key_hex:str=None, private_key_hex:str=None,\n         db_name:str='nostr-data', relay_urls:list=None,\n         ssl_options:dict={}, first_response_only:bool=True)\n\nA basic framework for common operations that a nostr client will need to execute.\nArgs: public_key_hex (str, optional): public key to initiate client private_key_hex (str, optional): private key to log in with public key. Defaults to None, in which case client is effectively read only relay_urls (list, optional): provide a list of relay urls. Defaults to None, in which case a default list will be used. ssl_options (dict, optional): ssl options for websocket connection Defaults to empty dict allow_duplicates (bool, optional): whether or not to allow duplicate event ids into the queue from multiple relays. This isn’t fully working yet. Defaults to False.\nTest setting account by private key or public key and handles as expected - note that some uses like the rebroadcastr client don’t need a private key since we aren’t creating new events\n\nimport ssl\n\n\nprivate_key = PrivateKey()\npublic_key = private_key.public_key\n\n# load client with no keys\nclient = Client(ssl_options={'cert_reqs': ssl.CERT_NONE})\n\n# load client with public key only\nclient = Client(ssl_options={'cert_reqs': ssl.CERT_NONE}, public_key_hex=public_key.hex())\nassert client.public_key.hex() == public_key.hex()\nassert client.private_key is None\n\n# load client with public key and private key\nclient = Client(ssl_options={'cert_reqs': ssl.CERT_NONE}, public_key_hex=public_key.hex(), private_key_hex=private_key.hex())\nassert client.public_key.hex() == public_key.hex()\nassert client.private_key.hex() == private_key.hex()\n\n# load client with private key only\nclient = Client(ssl_options={'cert_reqs': ssl.CERT_NONE}, private_key_hex=private_key.hex())\nassert client.public_key.hex() == public_key.hex()\nassert client.private_key.hex() == private_key.hex()\n\ntest adding and removing relays while disconnected\n\nrelay_urls_1 = [\n                'wss://nostr-2.zebedee.cloud',\n                'wss://rsslay.fiatjaf.com',\n                'wss://nostr-relay.wlvs.space',\n                'wss://nostr.orangepill.dev',\n                'wss://nostr.oxtr.dev'\n            ]\nrelay_urls_2 = [\n                'wss://relay.damus.io',\n                'wss://brb.io',\n                'wss://nostr-2.zebedee.cloud',\n                'wss://rsslay.fiatjaf.com',\n            ]\nclient = Client(private_key_hex=private_key.hex(), relay_urls=relay_urls_1)\nassert set(relay_urls_1) == set(client.relay_manager.relays.keys())\nclient.set_relays(relay_urls_2)\nassert set(relay_urls_2) == set(client.relay_manager.relays.keys())"
  },
  {
    "objectID": "client.html#adding-connection-methods",
    "href": "client.html#adding-connection-methods",
    "title": "client",
    "section": "Adding Connection Methods",
    "text": "Adding Connection Methods\nthe connection methods provide an easy, pythonic way to open and close connections with the relay manager in order to perform operations with the client.\nThe connections can be opened and closed by calling Client.connect() and Client.disconnect respectively. The client also provides a context manager that can be used as:\nwith Client() as client:\n    while True:\n        pass\nThe above code effectively runs the client until it is forced to exit for some interal reason at which point the connections are automatically closed.\n\nsource\n\nClient.disconnect\n\n Client.disconnect ()\n\n\nsource\n\n\nClient.connect\n\n Client.connect ()\n\n\nrelay_urls_1 = [\n                'wss://rsslay.fiatjaf.com',\n                'wss://nostr-relay.wlvs.space',\n                'wss://nostr.orangepill.dev',\n                'wss://nostr.oxtr.dev'\n            ]\nrelay_urls_2 = [\n                'wss://relay.damus.io',\n                'wss://brb.io',\n                'wss://rsslay.fiatjaf.com',\n            ]\nclient = Client(private_key_hex=private_key.hex(), relay_urls=relay_urls_1,\n                ssl_options={'cert_reqs': ssl.CERT_NONE})\nwith client:\n\n    # these are not hard asserts because some relays wont connect\n    print(client.relay_manager.connection_statuses)\n    client.set_relays(relay_urls_2)\n    print(client.relay_manager.connection_statuses)\nassert not any(client.relay_manager.connection_statuses.values())\n\n2023-01-14 08:45:02,009 - websocket - WARNING - websocket connected\n2023-01-14 08:45:02,197 - websocket - ERROR - Handshake status 500 Internal Server Error - goodbye\n2023-01-14 08:45:02,397 - websocket - WARNING - websocket connected\n\n\n/Users/ryanarmstrong/python/nostrfastr/nostrfastr/nostr.py:172: UserWarning: wss://nostr-relay.wlvs.space is not connected... removing relay.\n  warnings.warn(\n/Users/ryanarmstrong/python/nostrfastr/nostrfastr/nostr.py:172: UserWarning: wss://nostr.oxtr.dev is not connected... removing relay.\n  warnings.warn(\n\n\n{'wss://nostr.orangepill.dev': True, 'wss://rsslay.fiatjaf.com': True}\n2023-01-14 08:45:04,056 - websocket - WARNING - websocket connected\n2023-01-14 08:45:04,377 - websocket - WARNING - websocket connected\n{'wss://rsslay.fiatjaf.com': True, 'wss://brb.io': True, 'wss://relay.damus.io': True}\n\n\nMake sure that our context manager appropriately raises errors and closes connections\n\nfrom fastcore.test import test_fail\n\n2023-01-14 08:45:07,057 - websocket - ERROR - Handshake status 503 Service Unavailable - goodbye\n\n\n\ndef error_in_context():\n    with client:\n        raise Error()\ntest_fail(error_in_context)\n\n2023-01-14 08:45:07,606 - websocket - WARNING - websocket connected\n2023-01-14 08:45:07,902 - websocket - WARNING - websocket connected\n2023-01-14 08:45:08,183 - websocket - WARNING - websocket connected\n\n\n\nassert not any(client.relay_manager.connection_statuses.values())"
  },
  {
    "objectID": "client.html#publishing-subscriptions",
    "href": "client.html#publishing-subscriptions",
    "title": "client",
    "section": "Publishing Subscriptions",
    "text": "Publishing Subscriptions\nRequests to the relays are most easily understood as subscriptions since each request will continue to receive events to the message pool until the websocket connection is closed or the subscription passes an until criteria. NIP-01 clearly outlines the components of a subscription. Subscriptions are then executed as follows: - the relay runs a query for past events that meet the filter criteria - the events are returned to the client honoring any limit arguments specified - the relay may return an end of stored events (EOSE) notice as described in NIP-15 to inform the client that any further events received are newly published events - the relay will continue to return events that meet the subscription filter criteria until one of 3 things happen: - a new subscription is sent with the same subscription_id and overwrites the existing subscription - the client sends a CLOSE message to the relay to close the subscription - the websocket between the client and the relay is closed\nSubscription filters can be created from the Filter class in python-nostr with the arguments as shown below\n\nsource\n\nClient.get_notices_from_relay\n\n Client.get_notices_from_relay ()\n\ncalls the _notice_handler method on all notices from relays\n\nsource\n\n\nClient.publish_subscription\n\n Client.publish_subscription\n                              (filters:Union[nostr.filter.Filter,nostr.fil\n                              ter.Filters], subscription_id:str='724a1d59-\n                              f5bc-452b-8859-61eb6f5da7c2')\n\npublishes a request from a subscription id and a set of filters. Filters can be defined using the request_by_custom_filter method or from a list of preset filters (as of yet to be created):\nArgs: request_filters (Filters): list of filters for a subscription subscription_id (str): subscription id to be sent to relay. defaults to a random guid\nbelow we make and publish a simple subscription that requests posts from Jack Dorsey’s pubkey with a limit of 10. This will initially only return 10 events and then would continue to return new posts from Jack if we left the connection open.\nwe can see that python-nostr has also added the subscription to a dictionary of subscriptions for each relay in the relay manager.\n\nurl='ws://127.0.0.1:6969'\nclient = Client(private_key_hex=private_key.hex(), relay_urls=[url],\n                ssl_options={'cert_reqs': ssl.CERT_NONE})\n\njacks_pubkey = PublicKey.from_npub('npub1sg6plzptd64u62a878hep2kev88swjh3tw00gjsfl8f237lmu63q0uf63m').hex()\n\na_filter = Filter(\n    authors=[jacks_pubkey],\n    limit=10\n)\nwith client:\n    subscription_id = str(uuid.uuid4())\n    client.publish_subscription(filters=a_filter, subscription_id=subscription_id)\n    for relay in client.relay_manager:\n        assert subscription_id in relay.subscriptions.keys()\n\n2023-01-14 08:45:12,102 - websocket - WARNING - websocket connected"
  },
  {
    "objectID": "client.html#retrieving-events",
    "href": "client.html#retrieving-events",
    "title": "client",
    "section": "Retrieving Events",
    "text": "Retrieving Events\nAs a result, the same request likely does not need to be made twice as long as the connection is still open. New events for any subscriptions can be retrieved using the get_events method.\nThe message_pool also contains notices (effectively plain english errors from the relay) and end of subscription notices, which let you know that the relay is done sending information at the moment (but may resume if more events come in). These different types of events will be handled next. First…\n\nsource\n\nClient.insert_event_to_database\n\n Client.insert_event_to_database\n                                  (event_msg:nostr.message_pool.EventMessa\n                                  ge)\n\n\nsource\n\n\nClient.get_events_pool\n\n Client.get_events_pool ()\n\ncalls the _event_handler method on all events from relays\nlet’s publish the same subscription and get the events. We will clear the events data table of our test database.\n\nclient = Client(private_key_hex=private_key.hex(),\n                ssl_options={'cert_reqs': ssl.CERT_NONE},\n                db_name='test', relay_urls=['wss://relay.damus.io'])\nwith client.db_conn as con:\n    if client.db_name != 'test':\n        raise ValueError(f'should not be TRUNCATING a non test database - current database is {client.db_name}')\n    con.execute(f'DELETE FROM events')\nwith client:\n    subscription_id = str(uuid.uuid4())\n    client.publish_subscription(filters=a_filter, subscription_id=subscription_id)\n    client.get_events_pool()\n\n2023-01-14 08:45:18,128 - websocket - WARNING - websocket connected\n\n\nSee what events we got.\n\nNote: there could be more than 10 events received. In testing I got 20 events because two different relays had a different set of events for Jack.\n\n\nwith client.db_conn as con:\n    df = pd.read_sql('select * from events', con)\ndf.info()\n\n<class 'pandas.core.frame.DataFrame'>\nIndex: 0 entries\nData columns (total 9 columns):\n #   Column           Non-Null Count  Dtype \n---  ------           --------------  ----- \n 0   id               0 non-null      object\n 1   pubkey           0 non-null      object\n 2   created_at       0 non-null      object\n 3   kind             0 non-null      object\n 4   tags             0 non-null      object\n 5   content          0 non-null      object\n 6   sig              0 non-null      object\n 7   subscription_id  0 non-null      object\n 8   url              0 non-null      object\ndtypes: object(9)\nmemory usage: 0.0+ bytes"
  },
  {
    "objectID": "client.html#end-of-stored-events-notice",
    "href": "client.html#end-of-stored-events-notice",
    "title": "client",
    "section": "End Of Stored Events Notice",
    "text": "End Of Stored Events Notice\nMake sure we have a method to print the end of stored message notice.\n\nsource\n\nClient.get_eose_from_relay\n\n Client.get_eose_from_relay ()\n\ncalls the _eose_handler end of subsribtion events from relays"
  },
  {
    "objectID": "client.html#publishing-events",
    "href": "client.html#publishing-events",
    "title": "client",
    "section": "Publishing Events",
    "text": "Publishing Events\nMake a method that can publish events\n\nsource\n\nClient.check_event_pubkey\n\n Client.check_event_pubkey (event:nostr.event.Event)\n\n\nsource\n\n\nClient.publish_event\n\n Client.publish_event (event:nostr.event.Event)\n\npublish an event and immediately checks for a notice from the relay in case of an invalid event\nArgs: event (Event): description\nWe will try to publish an event with the wrong public key and assert that it will fail.\n\nclient = Client(private_key_hex=private_key.hex(),\n                ssl_options={'cert_reqs': ssl.CERT_NONE},\n                db_name='test', relay_urls=[url])\n\nbad_event = Event(public_key=jacks_pubkey, content='this is also a test')\n\ndef error_on_invalid():\n    with client:\n        client.publish_event(event=bad_event)\n\ntest_fail(error_on_invalid)\n\n2023-01-13 19:46:09,749 - websocket - WARNING - websocket connected\n\n\nAnd now publishing a good event\n\ngood_event = Event(public_key=client.public_key.hex(), content='this is also a test', created_at=int(time.time()))\nassert good_event.created_at == int(time.time())\n\n# publishing events commented out for sake of others\nwith client:\n    client.publish_event(event=good_event)\n\n2023-01-13 19:46:11,881 - websocket - WARNING - websocket connected"
  },
  {
    "objectID": "client.html#special-methods-for-common-filters-and-events",
    "href": "client.html#special-methods-for-common-filters-and-events",
    "title": "client",
    "section": "Special Methods for Common Filters and Events",
    "text": "Special Methods for Common Filters and Events\nbelow are some methods to help create common filters and events used in the nostr protocol\nSee the nostr nips page for a full list of event types and specifications. These events will continue to be built out over time.\n\nsource\n\nClient.event_encrypted_message\n\n Client.event_encrypted_message (recipient_hex:str, message:str)\n\n\nsource\n\n\nClient.event_channel_metadata\n\n Client.event_channel_metadata ()\n\n\nsource\n\n\nClient.event_channel_mute_user\n\n Client.event_channel_mute_user ()\n\n\nsource\n\n\nClient.event_channel_hide_message\n\n Client.event_channel_hide_message ()\n\n\nsource\n\n\nClient.event_channel_message\n\n Client.event_channel_message ()\n\n\nsource\n\n\nClient.event_channel_metadata\n\n Client.event_channel_metadata ()\n\n\nsource\n\n\nClient.event_channel\n\n Client.event_channel ()\n\n\nsource\n\n\nClient.event_reaction\n\n Client.event_reaction ()\n\n\nsource\n\n\nClient.event_deletion\n\n Client.event_deletion (event_ids:Union[str,list], reason:str)\n\nevent to delete a single event by id\nArgs: event_ids (str|list): event id as string or list of event ids reason (str): a reason for deletion provided by the user\n\nsource\n\n\nClient.event_recommended_relay\n\n Client.event_recommended_relay (relay_list)\n\n\nsource\n\n\nClient.event_text_note\n\n Client.event_text_note (text:str)\n\ncreate a text not event\nArgs: text (str): text for nostr note to be published\n\nsource\n\n\nClient.event_metadata\n\n Client.event_metadata (name:str=None, about:str=None, picture:str=None)\n\nsummary\nArgs: self (Client): description name (str, optional): profile name. Defaults to None. about (str, optional): profile about me. Defaults to None. picture (str, optional): url to profile picture. Defaults to None.\nReturns: Event: Event to publish for a metadata update\n\nsource\n\n\nClient.filter_events_recommended_relays\n\n Client.filter_events_recommended_relays (authors:Union[str,list])\n\nbuild a filter from authors\nArgs: authors (Union[str,list]): an author or a list of authors to request\nReturns: Filter: A filter object to use with a subscription\n\nsource\n\n\nClient.filter_events_authors\n\n Client.filter_events_authors (authors:Union[str,list])\n\nbuild a filter from authors\nArgs: authors (Union[str,list]): an author or a list of authors to request\nReturns: Filter: A filter object to use with a subscription\n\nsource\n\n\nClient.filter_events_by_id\n\n Client.filter_events_by_id (ids:Union[str,list])\n\nbuild a filter from event ids\nArgs: ids (Union[str,list]): an event id or a list of event ids to request\nReturns: Filter: A filter object to use with a subscription\nLet’s try to do a metadata update\n\nmetadata_update = \\\n    client.event_metadata(name='python-nostr-testacct',\n                          about='i am a robot - dont mind me',\n                          picture='https://cdn-icons-png.flaticon.com/256/7603/7603393.png')\nwith client:\n    # publishing events commented out for sake of others\n    client.publish_event(metadata_update)\n    pass\nprint(metadata_update.to_json_object())\n\n2023-01-13 19:46:15,915 - websocket - WARNING - websocket connected\n{'id': '28420f2a726bcc46ba24660e167c276ee1e6231d9b70bab68e8d1d60315dfbee', 'pubkey': 'c5597eb728296cf5a6d32aae47237e6a6b5b4ab0fce254ecbadb63aa51dc9a52', 'created_at': 1673667975, 'kind': <EventKind.SET_METADATA: 0>, 'tags': [], 'content': '{\"name\": \"python-nostr-testacct\", \"about\": \"i am a robot - dont mind me\", \"picture\": \"https://cdn-icons-png.flaticon.com/256/7603/7603393.png\"}', 'sig': '07cdad3ac25019e88483ede586762c54eb045f1f7d73b25320c160b6685ff21de8070c4b284b79946d7712094bfb199152b82c7c851a6ee555c4ac011d2ea49a'}\n\n\n\nclient = Client(private_key_hex=private_key.hex(),\n                ssl_options={'cert_reqs': ssl.CERT_NONE},\n                db_name='test', relay_urls=['wss://relay.damus.io'])\n\nwith client:\n    new_filter = client.filter_events_recommended_relays(authors='c80b5248fbe8f392bc3ba45091fb4e6e2b5872387601bf90f53992366b30d720')\n    subscription_id = str(uuid.uuid4())\n    client.publish_subscription(filters=new_filter, subscription_id=subscription_id)\n    time.sleep(2)\n    print(client.relay_manager.relays)\n    client.get_events_pool()\n\n2023-01-13 19:55:56,805 - websocket - WARNING - websocket connected\n{'wss://relay.damus.io': {\n  \"url\": \"wss://relay.damus.io\",\n  \"policy\": {\n    \"read\": true,\n    \"write\": true\n  },\n  \"subscriptions\": [\n    {\n      \"id\": \"2ebf6fc4-d414-4eac-9401-aca91fae086f\",\n      \"filters\": [\n        {\n          \"authors\": [\n            \"82341f882b6eabcd2ba7f1ef90aad961cf074af15b9ef44a09f9d2a8fbfbe6a2\"\n          ],\n          \"limit\": 10\n        }\n      ]\n    },\n    {\n      \"id\": \"478279db-770a-4a01-9497-a6b51de8fba7\",\n      \"filters\": [\n        {\n          \"authors\": [\n            \"82341f882b6eabcd2ba7f1ef90aad961cf074af15b9ef44a09f9d2a8fbfbe6a2\"\n          ],\n          \"limit\": 10\n        }\n      ]\n    },\n    {\n      \"id\": \"244b13de-f8c0-4285-bcaa-2645b51cf31d\",\n      \"filters\": [\n        {\n          \"authors\": [\n            \"82341f882b6eabcd2ba7f1ef90aad961cf074af15b9ef44a09f9d2a8fbfbe6a2\"\n          ],\n          \"limit\": 10\n        }\n      ]\n    },\n    {\n      \"id\": \"46b6147a-b0f4-40c3-ac39-b92399d33926\",\n      \"filters\": [\n        {\n          \"authors\": [\n            \"82341f882b6eabcd2ba7f1ef90aad961cf074af15b9ef44a09f9d2a8fbfbe6a2\"\n          ],\n          \"limit\": 10\n        }\n      ]\n    },\n    {\n      \"id\": \"1d3eecd2-c1f8-4ee4-a8fe-c09d4202ff04\",\n      \"filters\": [\n        {\n          \"authors\": [\n            \"82341f882b6eabcd2ba7f1ef90aad961cf074af15b9ef44a09f9d2a8fbfbe6a2\"\n          ],\n          \"limit\": 10\n        }\n      ]\n    },\n    {\n      \"id\": \"125adb08-a146-4069-82e1-452d443052ef\",\n      \"filters\": [\n        {\n          \"authors\": [\n            \"82341f882b6eabcd2ba7f1ef90aad961cf074af15b9ef44a09f9d2a8fbfbe6a2\"\n          ],\n          \"limit\": 10\n        }\n      ]\n    },\n    {\n      \"id\": \"14599812-338b-4e4e-b538-21693423b5fa\",\n      \"filters\": [\n        {\n          \"authors\": [\n            \"82341f882b6eabcd2ba7f1ef90aad961cf074af15b9ef44a09f9d2a8fbfbe6a2\"\n          ],\n          \"limit\": 10\n        }\n      ]\n    },\n    {\n      \"id\": \"994a764c-8bd4-4c23-8a81-79351bf40da7\",\n      \"filters\": [\n        {\n          \"authors\": [\n            \"82341f882b6eabcd2ba7f1ef90aad961cf074af15b9ef44a09f9d2a8fbfbe6a2\"\n          ],\n          \"limit\": 10\n        }\n      ]\n    },\n    {\n      \"id\": \"42f466d7-d182-4fc4-b045-ea4fd2927b9c\",\n      \"filters\": [\n        {\n          \"authors\": [\n            \"82341f882b6eabcd2ba7f1ef90aad961cf074af15b9ef44a09f9d2a8fbfbe6a2\"\n          ],\n          \"limit\": 10\n        }\n      ]\n    },\n    {\n      \"id\": \"73b05f9a-0939-419a-b1b8-6c9187573bee\",\n      \"filters\": [\n        {\n          \"authors\": [\n            \"82341f882b6eabcd2ba7f1ef90aad961cf074af15b9ef44a09f9d2a8fbfbe6a2\"\n          ],\n          \"limit\": 10\n        }\n      ]\n    },\n    {\n      \"id\": \"93712053-bc4d-48da-9b19-9d11c024962e\",\n      \"filters\": [\n        {\n          \"authors\": [\n            \"82341f882b6eabcd2ba7f1ef90aad961cf074af15b9ef44a09f9d2a8fbfbe6a2\"\n          ],\n          \"limit\": 10\n        }\n      ]\n    },\n    {\n      \"id\": \"1d874191-1e1b-4fd6-9eb9-72bd36e820e3\",\n      \"filters\": [\n        {\n          \"authors\": [\n            \"82341f882b6eabcd2ba7f1ef90aad961cf074af15b9ef44a09f9d2a8fbfbe6a2\"\n          ],\n          \"limit\": 10\n        }\n      ]\n    },\n    {\n      \"id\": \"ab59d40d-fbc4-4b27-954f-98bc03b9d627\",\n      \"filters\": [\n        {\n          \"authors\": [\n            \"82341f882b6eabcd2ba7f1ef90aad961cf074af15b9ef44a09f9d2a8fbfbe6a2\"\n          ],\n          \"limit\": 10\n        }\n      ]\n    },\n    {\n      \"id\": \"70e45963-6109-4ae9-8f72-69808dad1885\",\n      \"filters\": [\n        {\n          \"kinds\": [\n            2\n          ],\n          \"authors\": [\n            \"c80b5248fbe8f392bc3ba45091fb4e6e2b5872387601bf90f53992366b30d720\"\n          ]\n        }\n      ]\n    },\n    {\n      \"id\": \"511a38b8-d5e7-4d8f-a8c8-bbaae4c038c2\",\n      \"filters\": [\n        {\n          \"kinds\": [\n            2\n          ],\n          \"authors\": [\n            \"c80b5248fbe8f392bc3ba45091fb4e6e2b5872387601bf90f53992366b30d720\"\n          ]\n        }\n      ]\n    },\n    {\n      \"id\": \"c7590d75-6b51-44e8-a1c9-fe168c4dd075\",\n      \"filters\": [\n        {\n          \"kinds\": [\n            2\n          ],\n          \"authors\": [\n            \"c80b5248fbe8f392bc3ba45091fb4e6e2b5872387601bf90f53992366b30d720\"\n          ]\n        }\n      ]\n    },\n    {\n      \"id\": \"7a1f2fd0-9306-463d-8f29-2f7e1e3e2e68\",\n      \"filters\": [\n        {\n          \"kinds\": [\n            2\n          ],\n          \"authors\": [\n            \"c80b5248fbe8f392bc3ba45091fb4e6e2b5872387601bf90f53992366b30d720\"\n          ]\n        }\n      ]\n    },\n    {\n      \"id\": \"68db2083-562e-4a55-a9f2-c61895431776\",\n      \"filters\": [\n        {\n          \"kinds\": [\n            2\n          ],\n          \"authors\": [\n            \"cc80b5248fbe8f392bc3ba45091fb4e6e2b5872387601bf90f53992366b30d720\"\n          ]\n        }\n      ]\n    }\n  ]\n}}\n\n\n\npd.read_sql('select * from events',con=client.db_conn)\n\n\n\n\n\n  \n    \n      \n      id\n      pubkey\n      created_at\n      kind\n      tags\n      content\n      sig\n      subscription_id\n      url"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "nostrfastr",
    "section": "",
    "text": "This package attempts to be a well documented and tested instance of a very basic client framework and other tools that use the nostr protocol. The goal is to help others understand nostr quickly and get started sending messages from python in minutes.\nContained is a collection of tools built on top of this basic Client class showing some potential uses of nostr any how quickly we can build on it in python.\n\nA “sentinel” node that serves as a barebones client to rebroadcast user data across additional nostr relays. While this is a relatively simple concept I haven’t seen much discussion around the potential benefits and implications.\nnotifyr - a decorator that will alert on success or failure of any decorated function via nostr DM\na vanity address generator decorated with the notifyr function so you can leave it running and get notified when it finishes"
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "nostrfastr",
    "section": "Install",
    "text": "Install\npip install nostrfastr\nor alternatively, clone the github repositor and refer to this guide to get started working in nbdev."
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "nostrfastr",
    "section": "How to use",
    "text": "How to use\nDocumentation can be found at https://armstrys.github.io/nostrfastr/\n\nfrom nostrfastr.client import Client\n\nConnect and perform an operation…\n\nwith Client(relay_urls=['wss://relay.damus.io']) as client:\n    print('Are we connected?')\n    print('\\t', client.relay_manager.connection_statuses)\nprint('Are we connected?')\nprint('\\t', client.relay_manager.connection_statuses)\n\nAre we connected?\n     {'wss://relay.damus.io': True}\nAre we connected?\n     {'wss://relay.damus.io': False}\n\n\nAnd use the client to build something useful with nostr - like a bot that notifies you of your python processing status on long code runs\n\nfrom nostrfastr.notifyr import notifyr\n\n\n@notifyr\ndef raise_error():\n    raise Exception('Oh no! Process failed!')\n\n@notifyr\ndef success():\n    return 1+1\n\nOr generate an vanity address and have it notify you at another nostr address when it’s done\n\nfrom nostrfastr.vanity import vanity_notifyr\n\nprivate_key = vanity_notifyr(startswith='23', style='npub')\nprint(private_key.public_key.bech32())\n\n/Users/ryanarmstrong/python/nostrfastr/nostrfastr/client.py:479: UserWarning: the current implementation of messages should be used with caution\n                    see https://github.com/nostr-protocol/nips/issues/107\n  warnings.warn('''the current implementation of messages should be used with caution\n\n\nIt might take 0 seconds to find a npub pubkey that starts with npub123. Note that this is a very rough estimate and due to the random nature of finding vanity keys it could take MUCH longer.\nnpub1237z2shf8rlgs8xqg0cggz7dhxjtkszy205wesht2xr3nat86m7s30lqw5"
  }
]